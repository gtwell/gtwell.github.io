<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python对字典排序以及使用matplotlib画图]]></title>
    <url>%2F2018%2F06%2F05%2Fpython%E5%AF%B9%E5%AD%97%E5%85%B8%E6%8E%92%E5%BA%8F%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8matplotlib%E7%94%BB%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[123456import pickledata = list(range(100))pickle.dump(data, open('b.pkl', 'wb')load_data = pickle.load(open('b.pkl', 'rb')) 1python3 test.py | tee output.txt python中如何对字典根据值进行排序123456from collections import Counterlists = [1., 2., 3., 1., 2., 2., 3., 1., 1.]count_values = Counter(lists)sort_values = sorted(count_values.items(), key=lambda x:x[1], reverse=True)# [(1.0, 4), (2.0, 3), (3.0, 2)] 123456789101112131415161718192021222324import numpy as np import pandas as pd import matplotlib as mpl import matplotlib.pyplot as plt#其中row_ins_rect是numpy.ndarray二维数组#我是从pandas的DataFrame中取出来的，所以上面导了4个包fig = plt.figure() ax1 = fig.add_subplot(1,2,1) ax1.imshow(row_ins_rect, cmap=plt.cm.gray) ax2 = fig.add_subplot(1,2,2) ax2.imshow(row_ins_rect, cmap=plt.cm.gray_r) plt.show() #或者：implot = plt.imshow(row_ins_rect, cmap="gray")#选一个漂亮的颜色 #设置images之间的距离为0plt.subplots_adjust(wspace=0, hspace=0, left=0, right=1, bottom=0, top=1)# 让图摆放更加美观plt.tight_layout()plt.show() 参考How to remove gaps between images in matplotlib?]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL基本语法（一）]]></title>
    <url>%2F2018%2F05%2F25%2FSQL%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[创建和删除创建名为 test_01 的数据库1create database test_01; 删除名为 test_01 的数据库1drop database test_01; test_01数据库改名(不推荐), 后期的mysql已经取消了1rename database olddbname to newdbname 对一张表的修改新建数据表123456create table 表的名字(列名a 数据类型(数据长度),列名b 数据类型(数据长度)，列名c 数据类型(数据长度)); 1create table employee (id int(10),name char(20),phone int(12)); 删除一张表1drop table name; 插入数据1insert into 表的名字(列名a,列名b,列名c) values(值1,值2,值3); 12345insert into employee(id,name,phone) values(01,&apos;Tom&apos;,110110110);insert into employee values(02,&apos;Jack&apos;,119119119);insert into employee(id,name) values(03,&apos;Rose&apos;); 重命名一张表1alter table old_name rename new_name; 对一列的修改(对表结构的修改)增加一列1alter table 表名 add colunm 列名 数据类型 约束; 新增加的列，被默认放置在这张表的最右边。如果要把增加的列插入在指定位置，则需要在语句的最后使用after关键词(after 列1 表示新增的列被放置在 “列1” 的后面。如果想放在第一列的位置，则使用 FIRST 关键词1alter table employee add column height2 int(4) default 170 first; 删除一列1alter table 表名字 drop 列名字; 重命名一列1alter table 表名字 change 原列名 新列名 数据类型 约束; 改变数据类型1alter table 表名字 modify 列名字 新数据类型; 修改表中某个值1update 表名字 set 列1=值1,列2=值2 where 条件; 删除一行的值1delete from 表名字 where 条件; 关键字 LIKE 在SQL语句中和通配符一起使用，通配符代表未知字符。SQL中的通配符是 _ 和 % 。其中 _ 代表一个未指定字符，% 代表不定个未指定字符。12select name,age,phone from employee where name like &apos;J%&apos;;select name,age,phone from employee where phone like &apos;1101__&apos;; 索引12alter table 表名字 add index 索引名 (列名);create index 索引名 on 表名字 (列名); 123alter table employee add index idx_id (id); #在employee表的id列上建立名为idx_id的索引create index idx_name on employee (name); #在employee表的name列上建立名为idx_name的索引 使用命令 show index from 表名字查看刚才新建的索引 视图创建视图1create view 视图名 (列a,列b,列c) as select 列1,列2,列3 FROM 表名字; 导入导入操作，可以把一个文件里的数据保存进一张表1load data local infile &apos;文件路径和文件名&apos; into table 表名字; 导出123mysqldump -u root -p 数据库名&gt;备份文件名; #备份整个数据库mysqldump -u root -p 数据库名 表名字&gt;备份文件名; #备份整个表 1mysqldump -u root -p mysql_shiyan &gt; bak.sql; 恢复先新建一个database test1create database test; 退出来，命令行中执行1mysql -u root -p test &lt; bak.sql 参考MySQL 基础课程]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[归并排序和快速排序算法(2)]]></title>
    <url>%2F2018%2F05%2F15%2F%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%92%8C%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-2%2F</url>
    <content type="text"><![CDATA[归并排序的大致流程图如下: 1.原地归并的抽象方法 12345678910111213public static void merge(Comparable[] a, int lo, int mid, int hi)&#123; // 将a[lo..mid] 和 a[mid+1..hi] 归并 int i = lo, j = mid+1; for (int k = lo; k &lt;= hi; k++) aux[k] = a[k]; for (int k = lo; k &lt;= hi; k++) if (i &gt; mid) a[k] = aux[j++]; else if (j &gt; hi) a[k] = aux[i++]; else if (less(aux[j], aux[i]) a[k] = aux[j++]; else a[k] = aux[i++];&#125; 2.自顶向下的归并排序 12345678910111213141516171819public class Merge&#123; private static Comaprable[] aux; // 归并所需的辅助数组 public static void sort(Comparable[] a) &#123; aux = new Comparable[a.length]; sort(a, 0, a.length - 1); &#125; private static void sort(Comparable[] a, int lo, int hi) &#123; // 将数组a[lo..hi]排序 if (hi &lt;= lo) return; int mid = lo + (hi - lo)/2; sort(a, lo, mid); sort(a, mid+1, hi); merge(a, lo, mid, hi); &#125;&#125; 3.自顶向上的归并排序 12345678910111213public class MergeBU&#123; private static Comparable[] aux; // 归并所需的辅助数组 public static void sort(Comparable[] a) &#123; // 进行lgN次两两归并 int N = a.length; aux = new Comparable[N]; for (int sz = 1; sz &lt; N; sz = sz + sz) for (int lo = 0; lo &lt; N-sz; lo += sz + sz) merge(a, lo, lo+sz-1; Math.min(lo+sz+sz-1, N-1)); &#125;&#125; 4.快速排序 12345678910111213141516public class Quick&#123; public static void sort(Comparable[] a) &#123; StdRandom.shuffle(a); sort(a, 0, a.length - 1); &#125; private static void sort(Comparable[] a, int lo, int hi) &#123; if (hi &lt;= lo) return; int j = partition(a, lo, hi); sort(a, lo, j-1); sort(a, j+1, hi); &#125;&#125; 5.三项切分的快速排序 12345678910111213141516171819public class Quick3way&#123; private static void sort(Comparable[] a, int lo, int hi) &#123; // 调用此方法的共有方法sort()请见算法4. if (hi &lt;= lo) return; int lt = lo, i = lo+1, gt = hi; Comparable v = a[lo]; while(i &lt;= gt) &#123; int cmp = a[i].compareTo(v); if (cmp &lt; 0) exch(a, lt++, i++); else if (cmp &gt; 0) exch(a, i, gt--); else i++; &#125; // 现在 a[lo..lt-1] &lt; v = a[lt..gt] &lt; a[gt+1..hi] sort(a, lo, lt - 1); sort(a, gt + 1, hi); &#125;&#125; 参考1.归并排序算法原理分析与代码实现]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈和排序实现(1)]]></title>
    <url>%2F2018%2F05%2F13%2F%E6%A0%88%E5%92%8C%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0-1%2F</url>
    <content type="text"><![CDATA[1.栈的实现2.排序算法(1)–选择,插入和希尔排序 栈的实现123456789101112131415161718192021222324252627282930313233343536373839404142import java.utils.Iterator;public class ResizingArrayStack&lt;Item&gt; implements Iterable&lt;Item&gt;&#123; private Item[] a = (Item[]) new Object[1]; private int N = 0; public boolean isEmpty() &#123; return N == 0; &#125; public int size() &#123; return N; &#125; private void resize(int max) &#123; // 将栈移动到一个大小为max的新数组 Item[] temp = (Item[]) new Object[max]; for (int i = 0; i &lt; N;, i++) temp[i] = a[i]; a = temp; &#125; public void push(Item item) &#123; // 将元素添加到栈顶 if (N == a.length) resize(2*a.length()); a[N++] = item; &#125; public Item pop() &#123; // 从栈顶删除元素 Item item = a[--N]; a[N] = null; if (N &gt; 0 &amp;&amp; N == a.length/4) resize(a.length/2); return item; &#125; public Iterator&lt;Item&gt; iterator() &#123; return new ReverseArrayIterator(); &#125; private class ReverseArrayIterator implements Iterator&lt;Iterm&gt; &#123; // 支持后进先出的迭代 private int i =N; public boolean hasNext() &#123; return i &gt; 0; &#125; public Item next() &#123; return a[--i]; &#125; public void remove() &#123; &#125; &#125; &#125; 排序算法(1)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class Example&#123; // 选择排序 public statci void selectionSort(Comparable[] a) &#123; int N = a.length; for (int i = 0; i &lt; N; i++) &#123; // 将a[i]和a[i+1..N]中最小的元素交换) int min = i; for (int j = i+1; j &lt; N; j++) if (less(a[j], a[min])) min = j; exch(a, i, min); &#125; &#125; // 插入排序 public statci void insertionSort(Comparable[] a) &#123; int N = a.length; for (int i = 0; i &lt; N; i++) &#123; for (int j = i; j &gt; 0 &amp;&amp; less(a[j], a[j-1]; j--) exch(a, j, j-1); &#125; &#125; // 希尔排序 public statci void shellSort(Comparable[] a) &#123; int N = a.length; int h = 1; while (h &lt; N/3) h = 3*h + 1; while(h &gt;= 1) &#123; for (int i = 0; i &lt; N; i++) &#123; for (int j = i; j &gt;=h &amp;&amp; less(a[j], a[j-h); j -= h;) exch(a, j, j-h) &#125; h = h/3; &#125; &#125; // 判断大小关系 private static boolean less(Comparable v, Comparable w) &#123; return v.compareTo(w) &lt; 0; &#125; // 交换数组中两个元素 private static void exch(Comparable[] a, int i, intj) &#123; Comparable t = a[i]; a[i] = a[j]; a[j] = t; &#125; private static void show(Comparable[] a) &#123; for (int i = 0; i &lt; a.length; i++) StdOut.print(a[i] + " "); StdOut.println(); &#125; // 检查是否排序成功 public static boolean isSorted(Comparable[] a) &#123; for (int i = 0; i &lt; a.lenght; i++) if (less(a[i], a[i-1]) return false; return true; &#125; public static void main(String[] args) &#123; // 从标准输入读取字符串,将他们排序并输出 String[] a = In.readStrings(); // 调用函数; shellSort(); assert isSorted(); show(a); &#125;&#125; 参考1.算法第四版]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据分析常用python库]]></title>
    <url>%2F2018%2F05%2F07%2F%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B8%B8%E7%94%A8python%E5%BA%93%2F</url>
    <content type="text"><![CDATA[Python3 cookbookMarkdownLiaoxuefengPython3 officialdocumentationLeetcodePython projectRegex Data Analysis Python for Data Analysis利用Python进行数据分析Python Data Science Handbook Python数据科学手册 101-numpy-puzzles 100-pandas-puzzles matplotlib pillow seaborn Requests Machine Learning and Deep Learning Tensorflow 中文教程 tutorial PyTorch PyTorch folked from github PyTorch入门 keras keras官方中文文档 keras中文文档(第三方) mxnet mxnet video mxnet中文文档 opencv Scikit-learn 中文文档scikit-learn 爬虫笔记]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中os.walk, string的split函数, os.path.split]]></title>
    <url>%2F2018%2F05%2F03%2Fpython%E4%B8%ADos-walk-string%E7%9A%84split%E5%87%BD%E6%95%B0-os-path-split%2F</url>
    <content type="text"><![CDATA[python中os.walk, split以及os.path.split介绍1. os.walk2. split 和 join3. os.path.split 1 目录形式如下:12345678910111213141516/home/ubuntu/data/walk/▾ walk1/ ▾ walk3/ 1.py 2.py a.py 1.py 2.py a.py▾ walk2/ 1.py 2.py a.py 1.py 2.py a.py 123456789101112131415161718192021222324252627path = '/home/ubuntu/data/walk'for parent, dirs, files in os.walk(path): print(parent, dirs, files) &gt;&gt;&gt;outputwalk ['walk2', 'walk1'] ['1.py', '2.py', 'a.py']walk/walk2 [] ['1.py', '2.py', 'a.py']walk/walk1 ['walk3'] ['1.py', '2.py', 'a.py']walk/walk1/walk3 [] ['1.py', '2.py', 'a.py']for parent, dirs, files in os.walk(path): for file in files: print(file) &gt;&gt;&gt;output1.py2.pya.py1.py2.pya.py1.py2.pya.py1.py2.pya.py os.walk可以遍历某个文件夹下面所有的文件和目录 2 split and join :123456s = &apos;a b / c d/ e&apos;s = s.split(sep=&apos;/&apos;)print(s)output &gt; [&apos;a b &apos;, &apos; c d&apos;, &apos; e&apos;]&apos;|&apos;.join(s)output &gt; &apos;a b | c d| e&apos; 3 os.path.split(path):1234path = &apos;home/ubuntu/train/a.py&apos;a, b = os.patho.split(path)a &gt; &apos;home/ubuntu/train&apos;b &gt; &apos;a.py&apos; reference1.Python的os.walk()方法详细讲解2.Python中os和shutil模块实用方法集锦3.python 中的split()函数和os.path.split()函数]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[conda创建虚拟环境和python换源]]></title>
    <url>%2F2018%2F05%2F02%2Fconda%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E5%92%8Cpython%E6%8D%A2%E6%BA%90%2F</url>
    <content type="text"><![CDATA[python源 阿里云 http://mirrors.aliyun.com/pypi/simple/ 中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/ 豆瓣(douban) http://pypi.douban.com/simple/ 清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/ 中国科学技术大学 http://pypi.mirrors.ustc.edu.cn/simple/ 临时使用可以在使用pip的时候在后面加上-i参数，指定pip源 永久修改linux: 修改 ~/.pip/pip.conf (没有就创建一个)， 内容如下：12[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple 参考1.更换pip源到国内镜像 conda指令 查看当前存在哪些虚拟环境 1conda env list 或 conda info -e 检查更新当前conda 1conda update conda 查看conda安装了哪些包 1conda list 创建python虚拟环境 1conda create -n your_env_name python=X.X(2.7, 3.6) 查看python版本 1python --version 激活虚拟环境 1source activate your_env_name 这时再使用python --version可以检查当前python版本是否为想要的 对虚拟环境中安装额外的包 1conda install -n your_env_name need_package 关闭虚拟环境 1source deactivate 删除虚拟环境 1conda remove -n your_env_name --all 删除环境中某个包 1conda remove --name your_env_name package_name 参考1.用conda创建python虚拟环境2.Conda常用命令]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中argparse用法以及深拷贝和浅拷贝]]></title>
    <url>%2F2018%2F04%2F25%2Fpython%E4%B8%ADargparse%E7%94%A8%E6%B3%95%E4%BB%A5%E5%8F%8A%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[1.argparse1234567891011import argparseparser = argparse.ArgumentParser("描述")# x代表必须要加的参数# -x代表指定的短参数，如-h, 为可选参数#--x代表指定的长参数，如--help, 为可选参数# 这两种方式可以同存，也可以只存在一个parser.add_argument('-x', type=int, help="the base") args = parser.parse_args() 上一个用法中-x必须指定参数值，否则就会报错，有没有像-h那样，不需要指定参数值的呢，答案是有，通过定义参数时指定action=”store_true”即可，用法如下 123parser.add_argument("-v", "--verbose", help="increase output verbosity", action="store_true") 类型 type:默认的参数类型为str，如果要进行数学计算，需要对参数进行解析后进行类型转换，如果不能转换则需要报错，这样比较麻烦。 可选值choices=[]: 1234parser.add_argument("-v", "--verbosity", type=int, choices=[0, 1, 2], help="increase output verbosity") 另外增加参数默认值 12345parser.add_argument("-v", "--verbosity", type=int, choices=[0, 1, 2], default=1, help="increase output verbosity") 参考1.python argparse用法总结2.argparse3.python中的argparse4.vim cheat sheet 2.copy() 和 deepcopy() 区别copy() 为浅拷贝，不会产生一个独立的对象单独存在，与原始对象共同变化。deepcopy()为深拷贝，改变原有被复制对象，不会对已经复制出来的新对象产生影响。 123456789import copya = [1, 2, [3, 4]]b = copy.copy(a)c = copy.deepcopy(a)a[2][0] = 1print(a) #[1, 2, [1, 4]]print(b) #[1, 2, [1, 4]]print(c) #[1, 2, [3, 4]] 参考1.Python-copy()与deepcopy()区别 3.导入不同目录下的模块目录形式如下 folder folder1 __init__.py a.py c.py folder2__init__.py b.py __init__.py b.py内容如下 12from folder1 import afrom folder2.c import * 一般这样的情况会报错,我们需要在python环境变量中加入搜索顺序。 1vim ~/.bashrc 1export PYTHONPATH=&apos;.&apos;]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[push github 和一些Linux快捷键]]></title>
    <url>%2F2018%2F04%2F18%2Fpush-github-%E5%92%8C%E4%B8%80%E4%BA%9BLinux%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[push github1.在GitHub上创建一个新的仓库，为了避免错误，初始化时，不要添加 README, license, o或者 gitignore 文件. 你可以等你将你的本地项目推送到GitHub之后，再来添加这些文件.2.打开 Git Bash.切换到你当前项目的目录下. 12345git initgit add . (代表添加所有文件)git commit -m "本次添加要说明的"git remote add orgin remote (在新建的respository里面copy)git push origin master 参考1.push本地仓库到GitHub2.廖雪峰的官方网站 vimvim 编辑多个文件1vim filename1 filename2 说明：上述命令同时打开了filename1，filename2两个文件，不过文件filename1的内容将占据整个vim窗口，要想在各个文件之间进行切换，我们可通过如下命令 ：n 切换到下一个文件 ：N 切换到上一个文件 ：n filename2 切换到文件filename2 我们提到每个打开的文件都对应着一个buffer，故可通过切换buffer来达到切换文件的目的，如下 ：ls 列出vim打开的所有文件的信息，包括文件名，buffer id等:sp filename(top and down):vsp filename(left and right) ：b2 切换到buffer id为2的buffer :bn 切换到当前buffer的下一个buffer :bp 切换当前buffer的前一个buffer ：bd 关闭当前buffer，对应文件也随之关闭 ：bd2 关闭buffer id为2的buffer，对应文件也随之关闭 我们可通过安装miniBufExplorer插件来简化buffer的切换。不过该插件有时会导致语法高亮显示失效，我们可通过命令：syntax on来恢复高亮。 vim 插件先下载Vundle 123451. git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim2. vim ~/.vimrc #添加信息见参考3. vim :PluginInstall 回车下载 下载相关插件只需要在vim .vimrc添加一行需要添加的就ok了 设置了F2为快捷键打开目录 梯度下降(backprop) 不想另开一篇blog,将就着 参考1.vim 多文件编辑（偶的linux笔记）2.业精于勤，荒于嬉；行成于思，毁于随3.Vundle4.nerdtree]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见的markdown用法]]></title>
    <url>%2F2018%2F04%2F16%2F%E5%B8%B8%E8%A7%81%E7%9A%84markdown%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1.标题(有的#后面要带空)格#代表标题，一个#表示字号最大，依次为小一号字体 代表标题 代表标题 代表标题 2.加粗，斜体**加粗**加粗*斜体*斜体 3.引用>代表引用 代表引用 4.列表项目* 1* 2* 3 1 2 3 + 1+ 2+ 3 1 2 3 5.分割线3个___, 3个***, 3个—都可以为分割线 6.链接行内链接:要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如， 12This is [an example](http://example.com/ &quot;Title&quot;) inline link. [This link](http://example.net/) has no title attribute. 参考链接:参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记 1This is [an example][id] reference-style link. 你也可以选择性地在两个方括号中间加上一个空格： 1This is [an example] [id] reference-style link. 接着，在文件的任意处，你可以把这个标记的链接内容定义出来： 1[id]: http://example.com/ &quot;Optional Title Here&quot; 7.插入图片Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式。行内式的图片语法看起来像是: 12![Alt text](/path/to/img.jpg) ![Alt text](/path/to/img.jpg &quot;Optional title&quot;) 参考式的图片语法则长得像这样： 1![Alt text][id] 「id」是图片参考的名称，图片参考的定义方式则和连结参考一样： 1[id]: url/to/image &quot;Optional title attribute&quot; hexo 中比较特殊：资源（Asset）代表 source 文件夹中除了文章以外的所有文件，例如图片、CSS、JS 文件等。比方说，如果你的Hexo项目中只有少量图片，那最简单的方法就是将它们放在 source/images 文件夹中。然后通过类似于 1![](/images/image.jpg) 的方法访问它们。 对于那些想要更有规律地提供图片和其他资源以及想要将他们的资源分布在各个文章上的人来说，Hexo也提供了更组织化的方式来管理资源。这个稍微有些复杂但是管理资源非常方便的功能可以通过将 config.yml 文件中的 post_asset_folder 选项设为 true 来打开。当资源文件管理功能打开后，Hexo将会在你每一次通过 hexo new [layout] &lt;title&gt;命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个 markdown 文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们，这样你就得到了一个更简单而且方便得多的工作流。通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。在Hexo 2时代，社区创建了很多插件来解决这个问题。但是，随着Hexo 3 的发布，许多新的标签插件被加入到了核心代码中。这使得你可以更简单地在文章中引用你的资源。 123&#123;% asset_path slug %&#125;&#123;% asset_img slug [title] %&#125;&#123;% asset_link slug [title] %&#125; 比如说：当你打开文章资源文件夹功能后，你把一个 example.jpg 图片放在了你的资源文件夹中，如果通过使用相对路径的常规 markdown 语法 ! ，它将 不会 出现在首页上。（但是它会在文章中按你期待的方式工作） 正确的引用图片方式是使用下列的标签插件而不是 markdown: 1&#123;% asset_img example.jpg This is an example image %&#125; 通过这种方式，图片将会同时出现在文章和主页以及归档页中。 Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用方括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如: 1&lt;http://example.com/&gt; 8. 制作一份待办事宜 Todo 列表- [ ] 支持以 PDF 格式导出文稿- [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率- [x] 新增 Todo 列表功能- [x] 修复 LaTex 公式渲染问题- [x] 新增 LaTex 公式编号功能 支持以 PDF 格式导出文稿 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 新增 Todo 列表功能 修复 LaTex 公式渲染问题 新增 LaTex 公式编号功能 9.高亮一段代码1234567@requires_authorizationclass SomeClass: passif __name__ == '__main__':# A comment print('hello world') 参考1. Markdown 语法说明 (简体中文版)2. 欢迎使用Cmd Markdown 编辑阅读器3. Markdown 语法 示例 字体 字号 颜色4. Hexo中播放网易云音乐的实践 每日几个命令:vim 撤销 u 反撤销 ctrl+rvim 打开文件定位到行 vim filename +n如何把ubuntu的本地文件传到云端服务器（SSH） 1scp /home/gtwell/a.png ubuntu@ip:/home/blog/source/images/ 1&lt;!-- more --&gt; hexo中设置阅读全文]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+第一篇博客]]></title>
    <url>%2F2018%2F04%2F15%2Fhexo-%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[使用hexo写第一篇博客 首先安装Nodejs相关文件(推荐去官网下载安装) 使用sudo npm install -g hexo安装hexosudo npm install -g hexo 终端mkdir新建一个blog目录，然后cd到blog目录下，继续初始化使用hexo init blognpm install 下载相关需要的配置, 执行hexo s(也就是hexo server)可以用浏览器打开ip:4000，看到一个新建的blog。哈哈哈，终于完成了一个。 新建一篇博客hexo new “the name” 发一篇文章三部曲： hexo clean hexo g (hexo generator) hexo d (hexo deploy) 参考:1 Mac上搭建基于GitHub的Hexo博客2 基于hexo+github搭建一个独立博客3 hexo官网4 theme&gt;next主题5.hexo的next主题个性化教程:打造炫酷网站 结束的时候说明一点，Ubuntu下面不能输入中文的时候加一句$ vim .bashrc$ export LC_ALL=en_US.UTF-8$ export LANG=en_US.UTF-8]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F04%2F15%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
